Phase 0 — No-churn hygiene (1–2 commits)

Kill inline styles in CategorySection and cards.
You already have src/styles/tokens.css. Create src/styles/components.css and move those big inline style objects (button, headers, panels, expandable content) into class names. This reduces prop noise and standardizes spacing/typography.

Create primitive UI building blocks.

src/components/ui/Card.tsx (outer shell + padding variants)

src/components/ui/Field.tsx (label + control row, mobile stack)

src/components/ui/ButtonIcon.tsx (the chevron with selected/hover states)
Replace the ad-hoc label+input markup in all option cards with <Field> to enforce consistent spacing.

Phase 1 — Folder structure (clear separation of concerns)

Proposed structure (minimal moving, maximum clarity):

src/
  app/
    routes/
      index.tsx            // router setup
      form.tsx             // FormPage
      summary.tsx
      receipt.tsx
    layout/
      Header.tsx
      Footer.tsx
      CollapsibleSidebar.tsx
  features/
    order/
      components/
        CategorySection.tsx
        OrderSummaryCard.tsx
        panels/
          DisplayOptionsPanel.tsx
          ShirtVersionPanel.tsx
          ColorVersionPanel.tsx
          ShirtColorPanel.tsx
          QuantityPanel.tsx
      hooks/
        useOrderForm.ts         // keep Zustand here
        selectors.ts            // memoized selectors
      schemas/
        formData.ts             // zod schema for FormData
      utils/
        calculations.ts         // getShirtVersionTotal, totals, validation
        imagePath.ts
        naming.ts               // getProductName, getRackDisplayName
      types.ts                  // co-located domain types (re-export from src/types if you want)
  components/
    ui/
      Card.tsx
      Field.tsx
      ButtonIcon.tsx
      SectionHeader.tsx
  config/
    colleges/
      michiganState.json
      arizonaState.json
    index.ts                   // loads/validates JSON with zod
  services/
    email/
      emailService.ts
      templates/
        order.html
  styles/
    tokens.css
    components.css
    pages.css
  types/                       // shared app-wide (thin)
    index.ts
  utils/
    format.ts                  // generic formatters (currency, pluralize)
    guard.ts                   // type guards


Why: routing/layout isolated under app/, domain logic under features/order/, and product catalogs under config/ (data-first). UI primitives sit in components/ui for reuse.

Phase 2 — Data model cleanup (reduce conditional UI complexity)

Right now the branching in CategorySection is driven by image file names and several “special cases.” Move to a data-driven catalog so the UI just renders what the data says.

Catalog JSON per college (config/colleges/*.json), shape like:

{
  "name": "Michigan State",
  "categories": [
    {
      "id": "display",
      "name": "Display Options",
      "panel": "displayOptions",
      "images": [
        { "file": "MSU Inline Display.png", "sku": "..." }
      ]
    },
    {
      "id": "tees",
      "name": "Tees/Hoodies",
      "panel": "shirtVersion",
      "images": [
        { "file": "M100965414.png", "sku": "M100965414", "excludeVersions": ["crewneck"] }
      ]
    },
    {
      "id": "color-variants",
      "name": "Color Variants",
      "panel": "colorVersion",
      "images": [
        { "file": "M100437896.png", "sku": "M100437896", "colors": ["black","forest","white","gray"] }
      ]
    }
  ]
}


Load and validate with zod. Export a typed CollegeCatalog so CategorySection can switch on panel rather than guessing from filename or hasColorVersions(imageName).

Remove hardcoded “tie-dye special case.” Encode these constraints in the JSON (excludeVersions, allowedColors) so the panel simply respects the config.

Benefit: CategorySection becomes a thin router: choose panel component by panel type, pass data, done.

Phase 3 — State & performance

Zustand selectors to avoid full-form rerenders.
Derive small selectors per product row:

const quantity = useOrderForm(s => s.quantities[imagePath]);
const setQty = useOrderForm(s => s.setQuantity);


Add shallow where mapping multiple values.

Derived totals in features/order/utils/calculations.ts.
Keep a single source for “total quantity” logic across shirts/colors/display/sweats.

Virtualize long grids in CategorySection with react-window once categories exceed ~30 cards. This keeps the page responsive on mobile.

Phase 4 — Styling system

You already have design tokens; finish the job:

Replace per-component spacing with tokens (--space-2/3/4) via class names.

Create scale utilities in CSS (e.g., .stack-3, .cluster, .grid-auto) or adopt a utility library consistently (Tailwind or your CSS token system, but not both).

Centralize card states:

.card base

.card--active (bigger, stronger shadow, border)

.card__toggle (chevron gray/active)
So we don’t duplicate interactive styles in JS.

Phase 5 — Forms & accessibility

Field component enforces semantics: <label htmlFor>, input id, aria-describedby for help text, and keyboard focus rings with tokens.

Add aria-expanded and aria-controls to the chevron button; the expandable region should have an id tied to it.

Numeric inputs: add inputMode="numeric" and pattern="[0-9]*" for mobile.

Phase 6 — Testing & CI

Vitest + React Testing Library for panels and the “add quantities” flow.

Playwright happy path: select college → add items → summary → email dry run.

Lint + type check in CI. Fail builds on type errors.

Phase 7 — Email & serialization

Move email template to services/email/templates/order.html and generate via a pure function from FormData.

Create a serializeOrder(formState, catalog) helper that normalizes quantities by SKU/version/color so the email and the receipt use the same shape.